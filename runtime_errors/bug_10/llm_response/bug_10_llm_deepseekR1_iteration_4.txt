The bug is caused by using blocking assignments (=) instead of non-blocking assignments (<=) in the shift logic. Blocking assignments evaluate and update immediately within the same clock cycle, creating a ripple effect where all bits take the new value of serial_in in one cycle. This causes the entire register to fill with the serial_in value (1111) instead of shifting one bit per cycle. Non-blocking assignments would capture the pre-update values of each bit, allowing proper sequential shifting from data[3] to data[0].