The issue is that within the sequential always block the designer is using blocking assignments (the "=" operator) to update the bits of the register. In sequential logic it is best practice to use nonblocking assignments so that all state updates occur concurrently on the clock edge. Because the blocking assignments execute sequentially within the same clock cycle, the code ends up using the already-updated value for the next assignment. As a result, when the first bit is updated to the new serial input, that value propagates through the rest of the bits in the same cycle so that all four bits end up with the serial input value (hence 1111 instead of the expected 0001). 

The root cause is that the sequential shifting is inadvertently performed using blocking assignments that cause an immediate update of each bit. The fix is to use nonblocking assignments in the shift-logic, which ensures that every bit is updated using the data values from the beginning of the clock edge rather than immediately altered values.