The bug occurs due to incorrect use of blocking assignments (=) in the shift register's sequential logic. When `shift_en` is active, the code updates `data[0]` with `serial_in` and immediately propagates this new value to `data[1]`, `data[2]`, and `data[3]` within the same clock edge. This causes all bits to take the new `serial_in` value simultaneously instead of shifting the previous state. 

Blocking assignments evaluate and update immediately, creating a combinational chain where all bits change in one cycle. This results in parallel loading of the serial input across all bits (e.g., `1111` instead of `0001`). To fix this, use non-blocking assignments (`<=`), which defer updates until after all right-hand sides are evaluated, preserving the previous state for proper shifting.