The bug is that the FSM never checks whether the 4â€bit input is in the valid range (0â€“9). In other words, regardless of whether num_in is 4'd5 or 4'd10 (or even 4'd15), the sequential always block just does

â€ƒâ€ƒstate <= num_in;
â€ƒâ€ƒvalid <= 1;

so even when the input is â€œinvalidâ€ (i.e., outside 0â€“9) the valid signal is still set to 1. Thatâ€™s why when the test bench drives num_in = 10 or 15, the test benchâ€™s checks for valid being 0 fail and print the error â€œInvalid input should not be valid.â€

Why this happens:
â€¢ The code assigns state from num_in directly without checking its range.
â€¢ There is no logic that detects if num_in is greater than 9 and then sets valid to 0 (or otherwise resets the state/output_data).
â€¢ As a result, invalid num_in values are treated the same as valid ones.

How to fix it:
Modify the always block so that before updating state (and valid), you check whether num_in is in the range 0â€“9. For example, you could write:

â€ƒâ€ƒalways @(posedge clk or posedge reset) begin
â€ƒâ€ƒâ€ƒif (reset) begin
â€ƒâ€ƒâ€ƒâ€ƒstate <= S0; // Default state on reset
â€ƒâ€ƒâ€ƒâ€ƒoutput_data <= 8'd0;
â€ƒâ€ƒâ€ƒâ€ƒvalid <= 0;
â€ƒâ€ƒâ€ƒend else begin
â€ƒâ€ƒâ€ƒâ€ƒif (num_in <= 4'd9) begin
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒstate <= num_in;
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒvalid <= 1;
â€ƒâ€ƒâ€ƒâ€ƒend else begin
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒstate <= S0; // Or another default state for invalid input
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒvalid <= 0;
â€ƒâ€ƒâ€ƒâ€ƒend
â€ƒâ€ƒâ€ƒend
â€ƒâ€ƒend

With this change, if num_in is 10 or 15 then valid will be 0 and (if desired) state (and subsequently output_data) will be set to a default â€œinvalidâ€ value. This fix makes the design behavior match the test bench expectations.

ğŸ” Related Documents:

- source_documents\verilog_fsm.pdf: 6
7 always@( * ) begin
8
Status = 3â€™b000;
9
case (CurrentState)
10
STATE_2: begin
11
Status = 3â€™b010;
12
end
13
STATE_3: begin
14
Status = 3â€™b011;
15
end
16
endcase
17 end
Alternatively, the output assignment for Status can be combined into the always@( * ) block that
chooses what the next state should be (see Program 21). It is seperated here for clarity.
4.5
A Complete FSM
In this tutorial we hasve discussed why the Moore machine FSM is useful in digital design and how...

- source_documents\verilog_fsm.pdf: Program 23 The complete FSM (part 1) from Figure 1
1 module
BasicFsm(
2
//
------------------------------------------------------------
3
// Inputs
4
//
------------------------------------------------------------
5
input
wire
Clock ,
6
input
wire
Reset ,
7
input
wire
A,
8
input
wire
B,
9
//
------------------------------------------------------------
10
11
//
------------------------------------------------------------
12
// Outputs
13
//...

- source_documents\Quick Start Guide to Verilog.pdf: 116
8.1.5 Changing the State Encoding Approach ....................................................
118
8.2 FSM DESIGN EXAMPLES ........................................................................................
119
8.2.1 Serial Bit Sequence Detector in Verilog ......................................................
119
8.2.2 Vending Machine Controller in Verilog ........................................................
121...

- source_documents\verilog_fsm.pdf: 2
STATE_1 = 3â€™b001 ,
3
STATE_2 = 3â€™b010 ,
4
STATE_3 = 3â€™b011 ,
5
STATE_4 = 3â€™b100;
As 3 bits can specify a total of 8 states (0-7), our encoding speciï¬es 3 potential states not speciï¬ed
as being actual states. There are several ways of dealing with this problem:
1. Ignore it, and always press Reset as a way of initializing the FSM.
2. Specify these states, and make non-conditional transitions from them to the STATE_Initial....

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\Quick Start Guide to Verilog.pdf: appear in a truth table (i.e., â€œ0000,â€ â€œ0001,â€
â€œ0010,â€ . . .). Your test bench should read in a
new input pattern every 10 ns. Your test bench
should
write
the
input
pattern
and
the
corresponding output of the DUT to an external
ï¬le called â€œoutput.txt.â€
6.4.2
Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 6.2. Your
test bench read in the input patterns from an
external ï¬le called â€œinput.txt.â€ This ï¬le should...
