The bug is in how the carry output (o_carry) is generated in the full adder. In a correctly implemented full adder built from half adders, the carry should be computed using an OR operation, not an AND. 

Here's what happens in your code:

1. The first half adder computes:
   - w_sum1 = i_a XOR i_b
   - w_carry1 = i_a AND i_b

2. The second half adder computes:
   - o_sum = w_sum1 XOR i_cin
   - w_carry2 = w_sum1 AND i_cin

The full adderâ€™s carry should be:
â€ƒâ€ƒo_carry = (i_a AND i_b) OR (w_sum1 AND i_cin)
â€ƒâ€ƒor equivalently,
â€ƒâ€ƒo_carry = w_carry1 OR w_carry2

However, your module mistakenly uses:
â€ƒâ€ƒassign o_carry = w_carry1 & w_carry2;

For example, if i_a = 1, i_b = 1, and i_cin = 0:
â€ƒâ€ƒw_carry1 becomes 1 (since 1 AND 1 = 1)
â€ƒâ€ƒw_sum1 becomes 0 (since 1 XOR 1 = 0)
â€ƒâ€ƒw_carry2 becomes 0 (since 0 AND 0 = 0)
Thus, o_carry = 1 AND 0 = 0, which is incorrect because the expected carry is 1.

To fix the bug, change the assignment of o_carry to use the OR operator (|) instead of the AND operator (&):

Change:
â€ƒâ€ƒassign o_carry = w_carry1 & w_carry2;
to:
â€ƒâ€ƒassign o_carry = w_carry1 | w_carry2;

This correction yields the proper full adder behavior as required by your testbench.

ğŸ” Related Documents:

- source_documents\Quick Start Guide to Verilog.pdf: EXAMPLE 4.5 DESIGN OF A HALF ADDER ............................................................. ............................................................. 56
EXAMPLE 4.6 DESIGN OF A FULL ADDER ............................................................. ............................................................. 57
EXAMPLE 4.7 DESIGN OF A FULL ADDER OUT OF HALF ADDERS .............................................. ............................................. 58...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\Quick Start Guide to Verilog.pdf: is called a half adder instead of a full adder is because it does not accommodate a carry in during the
computation, thus it does not provide all of the necessary functionality required for a positional adder.
Example 4.5 shows the design of a half adder. Notice that two combinational logic circuits are required in
order to produce the sum (the XOR gate) and the carry out (the AND gate). These two gates are in...

- source_documents\Quick Start Guide to Verilog.pdf: 11.3.4
Add the functionality to the computer model
from 11.3.3 the ability to perform the addition
instruction ADD_AB. Test your addition instruc-
tion by simulating the following program. The
ï¬rst addition instruction will perform xâ€œFEâ€ +
xâ€œ01â€
Â¼
xâ€œFFâ€
and
assert
the
negative
(N) ï¬‚ag. The second addition instruction will
perform xâ€œ01â€ + xâ€œFFâ€ Â¼ xâ€œ00â€ and assert the
carry (C) and zero (Z) ï¬‚ags. The third addition
instruction will perform xâ€œ7Fâ€ + xâ€œ7Fâ€ Â¼ xâ€œFEâ€...

- source_documents\Quick Start Guide to Verilog.pdf: always @ (A, B, ALU_Sel)
begin
case (ALU_Sel)
3â€™b000
: begin //-- Addition
//-- Sum and Carry Flag
{NZVC[0], Result} Â¼ A + B;
//-- Negative Flag
NZVC[3] Â¼ Result[7];
//-- Zero Flag
if (Result Â¼Â¼ 0)
NZVC[2] Â¼ 1;
else
NZVC[2] Â¼ 0;
//-- Twoâ€™s Comp Overflow Flag
if ( ((A[7]Â¼Â¼0) && (B[7]Â¼Â¼0) && (Result[7] Â¼Â¼ 1)) ||
((A[7]Â¼Â¼1) && (B[7]Â¼Â¼1) && (Result[7] Â¼Â¼ 0)) )
NZVC[1] Â¼ 1;
else
NZVC[1] Â¼ 0;
end
:
//-- other ALU operations go here...
:
default
: begin
Result Â¼ 8â€™hXX;
NZVC
Â¼ 4â€™hX;
end
endcase
end...

- source_documents\Quick Start Guide to Verilog.pdf: Example 6.2
Test bench for a sequential logic circuit
6.1.2 Printing Results to the Simulator Transcript
In the past test bench examples, the input and output values are observed using either the
waveform or listing tool within the simulator tool. It is also useful to print the values of the simulation to
a transcript window to track the simulation as each statement is processed. Messages can be printed...
