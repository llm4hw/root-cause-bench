The problem is that the â€œOâ€ case (for sending the letter O) is not actually executing three dashes as intended. In your state machine you have defined three states for Oâ€”O_DASH1, O_DASH2, and O_DASH3â€”but the code never actually transitions from one to the next. Instead, the same block handles all three states and, when the dash period (counter reaches DASH) is over, the state is reset immediately to IDLE. This means only one dash is produced rather than the three dashes expected for â€œO.â€

For example, in the always block you have:

â€ƒâ€ƒO_DASH1, O_DASH2, O_DASH3: begin  
â€ƒâ€ƒâ€ƒmorse_out <= 1;  
â€ƒâ€ƒâ€ƒif (counter < DASH) begin  
â€ƒâ€ƒâ€ƒâ€ƒcounter <= counter + 1;  
â€ƒâ€ƒâ€ƒend else begin  
â€ƒâ€ƒâ€ƒâ€ƒstate <= IDLE;  
â€ƒâ€ƒâ€ƒâ€ƒcounter <= 0;  
â€ƒâ€ƒâ€ƒâ€ƒmorse_out <= 0;  
â€ƒâ€ƒâ€ƒend  
â€ƒâ€ƒend

No matter which O state you are in, the â€œelseâ€ always resets to IDLE and never progresses to O_DASH2 or O_DASH3. This is why your test bench â€“ which checks after the letter should have finished its transmission â€“ finds that the â€œOâ€ output was not generated correctly (it produced only one dash instead of three).

To fix the bug, you need to change the state transitions for the O case so that the design steps through three distinct dash states before returning to IDLE. For example:

â€ƒâ€ƒO_DASH1: begin  
â€ƒâ€ƒâ€ƒmorse_out <= 1;  
â€ƒâ€ƒâ€ƒif (counter < DASH)  
â€ƒâ€ƒâ€ƒâ€ƒcounter <= counter + 1;  
â€ƒâ€ƒâ€ƒelse begin  
â€ƒâ€ƒâ€ƒâ€ƒcounter <= 0;  
â€ƒâ€ƒâ€ƒâ€ƒstate <= O_DASH2;  
â€ƒâ€ƒâ€ƒend  
â€ƒâ€ƒend  
â€ƒâ€ƒO_DASH2: begin  
â€ƒâ€ƒâ€ƒmorse_out <= 1;  
â€ƒâ€ƒâ€ƒif (counter < DASH)  
â€ƒâ€ƒâ€ƒâ€ƒcounter <= counter + 1;  
â€ƒâ€ƒâ€ƒelse begin  
â€ƒâ€ƒâ€ƒâ€ƒcounter <= 0;  
â€ƒâ€ƒâ€ƒâ€ƒstate <= O_DASH3;  
â€ƒâ€ƒâ€ƒend  
â€ƒâ€ƒend  
â€ƒâ€ƒO_DASH3: begin  
â€ƒâ€ƒâ€ƒmorse_out <= 1;  
â€ƒâ€ƒâ€ƒif (counter < DASH)  
â€ƒâ€ƒâ€ƒâ€ƒcounter <= counter + 1;  
â€ƒâ€ƒâ€ƒelse begin  
â€ƒâ€ƒâ€ƒâ€ƒcounter <= 0;  
â€ƒâ€ƒâ€ƒâ€ƒstate <= IDLE;  
â€ƒâ€ƒâ€ƒâ€ƒmorse_out <= 0;  
â€ƒâ€ƒâ€ƒend  
â€ƒâ€ƒend

This change makes sure that when select = 2â€™b01 (for the letter O), the FSM outputs three consecutive dashes (with appropriate timing for each) before returning to the IDLE state. Once you implement these state transitions, your simulation should produce the correct Morse code for O and the test bench error will be resolved.

ğŸ” Related Documents:

- source_documents\verilog_2001_ref_guide.pdf: for (i=0; i<=255; i=i+1)
                @(negedge clk)
                  data_bus = RAM[i];
            end
    default:$display(â€œillegal opcode in module %mâ€);
  endcase
end...

- source_documents\verilog_fsm.pdf: Figure 5 The circuit generated by Program 17 (this is an erroneous circuit!)
Pass
Trigger
C
A
1'b0
0
1
Latch
C
Program 18 An always@( * ) block that will not generate latches
1 wire Trigger , Pass;
2 reg A, C;
3
4 always @( * ) begin
5
A = 1â€™b0;
6
C = 1â€™b1;
7
if (Trigger) begin
8
A = Pass;
9
C = Pass;
10
end
11 end
Figure 6 The circuit generated by Program 18 (this is correct!)
Pass
Trigger
C
A
1'b0
0
1
1
0
1'b1
11...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\RTL error analysis.pdf: // Moore model FSM
module  Moore_Model(
output [1:0]   y_out,
input
X_in, clock, reset
);  
reg [1:0]    state;
parameter S0=2â€™b00, S1=2â€™b01,S2=2â€™b10,S3=2â€™b11;
always @ (posedge clk, negedge reset)
if (reset == 0) state <= S0;
else
case(state)
S0:   if (~X_in) state <= S1; else state <= S0;
S1:   if (X_in)   state <= S2; else state <= S3;
S2:   if (~X_in) state <= S3; else  state <= S2;
S3:   if (~X_in) state <= S0; else   state <= S3;
endcase
assign y_out = state; 
endmodule...

- source_documents\RTL error analysis.pdf: // structural model
module  Moore_Model_One(
output            y_out,A,B,
input
X_in, clock, reset
);  
wire     TA,TB;
assign  TA  = X_in&B;
assign  TB = X_in;
assign   y_out = A&B;
TFF  MA(A,TA,clock,reset);
TFF  MB(B,TB,clock,reset);
end module
// structural model
module  TFF(Q,T,CLK,RST_b);
output            Q;
input
T, CLK,RST_b;
reg
Q; 
always @ (posedge CLK, negedge RST_b)
if (RST_b == 0)  Q<= 1â€™b0;
else if (T)  Q <= ~Q;
end module
Structural description:
clocked sequential circuits...

- source_documents\Quick Start Guide to Verilog.pdf: case statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.
5.2.7
Design a Verilog model to implement the
behavior described by the 4-input truth table
in Fig. 5.4. Use procedural assignment and an
if-else statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output. Hint:
Notice that there are far more input codes pro-...
