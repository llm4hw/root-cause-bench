The error message "ERROR: Morse for O not correct." from your testbench indicates that the logic for generating the Morse code for the letter 'O' (which is represented by "---") is not functioning as expected. Let's break down the possible issues in the code:

1. **State Transition Issue**: For Morse code generation of 'O' (which should be three sequential DASH signals), you need to ensure that the state machine properly transitions through three DASH states (O_DASH1 -> O_DASH2 -> O_DASH3). However, your current code transitions to IDLE state after the first DASH in the O_DASH1 state itself. This is causing the testbench to not receive the expected three DASH signals and therefore generate the error.

2. **Fix**: You need to modify the logic for the O_DASH states so that the state machine transitions from O_DASH1 to O_DASH2 to O_DASH3 before returning to the IDLE state. Here’s a corrected snippet for handling the 'O' character:

    ```verilog
    O_DASH1: begin
        morse_out <= 1;
        if (counter < DASH) begin
            counter <= counter + 1;
        end else begin
            counter <= 0;
            state <= O_DASH2;  // Move to the next dash state
        end
    end
    O_DASH2: begin
        morse_out <= 1;
        if (counter < DASH) begin
            counter <= counter + 1;
        end else begin
            counter <= 0;
            state <= O_DASH3;  // Move to the final dash state
        end
    end
    O_DASH3: begin
        morse_out <= 1;
        if (counter < DASH) begin
            counter <= counter + 1;
        end else begin
            counter <= 0;
            state <= IDLE;  // After third DASH, return to IDLE
            morse_out <= 0;
        end
    end
    ```

3. **Testbench Timing Consideration**: Ensure that the time you wait in the testbench (`#150`) covers the duration for three DASH sequences plus any idle time between them. Each DASH is 30 time units (based on your parameter settings), so your wait time after setting the select signal should be enough to allow for all three DASHes and the transition back to IDLE.

By addressing the state transition logic as shown above, the simulation should work correctly, and you should not see the error message for the Morse code 'O' again.

🔍 Related Documents:

- source_documents\verilog_2001_ref_guide.pdf: for (i=0; i<=255; i=i+1)
                @(negedge clk)
                  data_bus = RAM[i];
            end
    default:$display(“illegal opcode in module %m”);
  endcase
end...

- source_documents\verilog_fsm.pdf: Figure 5 The circuit generated by Program 17 (this is an erroneous circuit!)
Pass
Trigger
C
A
1'b0
0
1
Latch
C
Program 18 An always@( * ) block that will not generate latches
1 wire Trigger , Pass;
2 reg A, C;
3
4 always @( * ) begin
5
A = 1’b0;
6
C = 1’b1;
7
if (Trigger) begin
8
A = Pass;
9
C = Pass;
10
end
11 end
Figure 6 The circuit generated by Program 18 (this is correct!)
Pass
Trigger
C
A
1'b0
0
1
1
0
1'b1
11...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\RTL error analysis.pdf: // Moore model FSM
module  Moore_Model(
output [1:0]   y_out,
input
X_in, clock, reset
);  
reg [1:0]    state;
parameter S0=2’b00, S1=2’b01,S2=2’b10,S3=2’b11;
always @ (posedge clk, negedge reset)
if (reset == 0) state <= S0;
else
case(state)
S0:   if (~X_in) state <= S1; else state <= S0;
S1:   if (X_in)   state <= S2; else state <= S3;
S2:   if (~X_in) state <= S3; else  state <= S2;
S3:   if (~X_in) state <= S0; else   state <= S3;
endcase
assign y_out = state; 
endmodule...

- source_documents\RTL error analysis.pdf: // structural model
module  Moore_Model_One(
output            y_out,A,B,
input
X_in, clock, reset
);  
wire     TA,TB;
assign  TA  = X_in&B;
assign  TB = X_in;
assign   y_out = A&B;
TFF  MA(A,TA,clock,reset);
TFF  MB(B,TB,clock,reset);
end module
// structural model
module  TFF(Q,T,CLK,RST_b);
output            Q;
input
T, CLK,RST_b;
reg
Q; 
always @ (posedge CLK, negedge RST_b)
if (RST_b == 0)  Q<= 1’b0;
else if (T)  Q <= ~Q;
end module
Structural description:
clocked sequential circuits...

- source_documents\Quick Start Guide to Verilog.pdf: case statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.
5.2.7
Design a Verilog model to implement the
behavior described by the 4-input truth table
in Fig. 5.4. Use procedural assignment and an
if-else statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output. Hint:
Notice that there are far more input codes pro-...
