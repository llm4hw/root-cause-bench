The root of the problem is not in the test bench but in how the state machine is written for the letter O. In the code the three O dash states are “joined” by listing them together (O_DASH1, O_DASH2, O_DASH3:) and are therefore given identical behavior. In the branch for these states the always block simply “fires” a dash (sets morse_out to 1) until the counter reaches DASH and then immediately resets the counter and forces state to IDLE. This means that instead of progressing through three separate dashes (with proper spacing between them, as is done for letter A using a SPACE_STATE) the state machine is “cutting off” the O sequence early. The simulation then produces an incorrect output for O (for example, only one dash or not the expected pattern) and the test bench’s check (which expects morse_out eventually to go low) fails with the error message “ERROR: Morse for O not correct.”

To fix the issue you need to implement sequential transitions for letter O rather than lumping O_DASH1, O_DASH2, and O_DASH3 into one case block that always goes directly to IDLE. For example, you could:
 
1. Separate the three states so that once the counter finishes a dash in O_DASH1, the machine transitions to an intermediate SPACE state before moving to O_DASH2, and similarly from O_DASH2 to O_DASH3.

2. Or change the “else” branch in the currently combined O_DASH1,2,3 case so that it checks which dash is currently executing and, if it isn’t the final dash, transitions to a spacing state (or directly to the next dash state) instead of always going to IDLE.

By ensuring that the state transitions properly step through each dash (and possibly include a spacing state between them), the module will produce three separate dash pulses for the letter O. This change causes morse_out to return low at the proper time and the test bench will then report that “Morse for O generated correctly.”

In short, the bug is that combining states for O prevents the proper sequential generation of the three dashes. The fix is to distinguish among the O dash states (and optionally include inter-dash spacing) so that the output follows the intended Morse code pattern.

🔍 Related Documents:

- source_documents\verilog_2001_ref_guide.pdf: for (i=0; i<=255; i=i+1)
                @(negedge clk)
                  data_bus = RAM[i];
            end
    default:$display(“illegal opcode in module %m”);
  endcase
end...

- source_documents\verilog_fsm.pdf: Figure 5 The circuit generated by Program 17 (this is an erroneous circuit!)
Pass
Trigger
C
A
1'b0
0
1
Latch
C
Program 18 An always@( * ) block that will not generate latches
1 wire Trigger , Pass;
2 reg A, C;
3
4 always @( * ) begin
5
A = 1’b0;
6
C = 1’b1;
7
if (Trigger) begin
8
A = Pass;
9
C = Pass;
10
end
11 end
Figure 6 The circuit generated by Program 18 (this is correct!)
Pass
Trigger
C
A
1'b0
0
1
1
0
1'b1
11...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\RTL error analysis.pdf: // Moore model FSM
module  Moore_Model(
output [1:0]   y_out,
input
X_in, clock, reset
);  
reg [1:0]    state;
parameter S0=2’b00, S1=2’b01,S2=2’b10,S3=2’b11;
always @ (posedge clk, negedge reset)
if (reset == 0) state <= S0;
else
case(state)
S0:   if (~X_in) state <= S1; else state <= S0;
S1:   if (X_in)   state <= S2; else state <= S3;
S2:   if (~X_in) state <= S3; else  state <= S2;
S3:   if (~X_in) state <= S0; else   state <= S3;
endcase
assign y_out = state; 
endmodule...

- source_documents\RTL error analysis.pdf: // structural model
module  Moore_Model_One(
output            y_out,A,B,
input
X_in, clock, reset
);  
wire     TA,TB;
assign  TA  = X_in&B;
assign  TB = X_in;
assign   y_out = A&B;
TFF  MA(A,TA,clock,reset);
TFF  MB(B,TB,clock,reset);
end module
// structural model
module  TFF(Q,T,CLK,RST_b);
output            Q;
input
T, CLK,RST_b;
reg
Q; 
always @ (posedge CLK, negedge RST_b)
if (RST_b == 0)  Q<= 1’b0;
else if (T)  Q <= ~Q;
end module
Structural description:
clocked sequential circuits...

- source_documents\Quick Start Guide to Verilog.pdf: case statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.
5.2.7
Design a Verilog model to implement the
behavior described by the 4-input truth table
in Fig. 5.4. Use procedural assignment and an
if-else statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output. Hint:
Notice that there are far more input codes pro-...
