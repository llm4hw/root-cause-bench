The problem turns out not to be with the test bench at all but in the state machine that should produce the three dashes for the letter â€œO.â€

What happens is that the code lumps O_DASH1, O_DASH2, and O_DASH3 in one case branch. In that branch the following occurs:

â€ƒâ€ƒâ€¢ morse_out is set to 1 (active)  
â€ƒâ€ƒâ€¢ the counter runs until it reaches DASH  
â€ƒâ€ƒâ€¢ then (once counter >= DASH) the state machine always goes directly to IDLE

That means that no matter whether youâ€™re in O_DASH1, O_DASH2, or O_DASH3 you only generate one DASH and then immediately drop back to IDLE. The expected behavior for â€œOâ€ (which in Morse Code should be â€œâ€” â€” â€”â€) is to sequence three separate dashes. Because the state machine never chains from O_DASH1 to O_DASH2 (and then O_DASH3) before returning to IDLE, the test bench eventually reports â€œERROR: Morse for O not correct.â€

To fix the bug, you need to modify the state transitions for the letter O. One solution is to have separate behavior for each O_DASH state such that:

â€ƒâ€ƒâ€“ When in O_DASH1, after the counter reaches DASH, go to an intermediate state (or directly to O_DASH2)  
â€ƒâ€ƒâ€“ When in O_DASH2, after the counter reaches DASH, go to O_DASH3  
â€ƒâ€ƒâ€“ When in O_DASH3, after the counter reaches DASH, then return to IDLE

Optionally, you might want to insert a spacing state between the dashes (similar to how it is done for A) so that the dashes do not immediately abut each other.

A corrected sketch for the O states might look like this:

--------------------------------------------------
â€ƒâ€ƒO_DASH1: begin
â€ƒâ€ƒâ€ƒmorse_out <= 1;
â€ƒâ€ƒâ€ƒif (counter < DASH)
â€ƒâ€ƒâ€ƒâ€ƒcounter <= counter + 1;
â€ƒâ€ƒâ€ƒelse begin
â€ƒâ€ƒâ€ƒâ€ƒcounter <= 0;
â€ƒâ€ƒâ€ƒâ€ƒstate <= O_DASH2;  // transition to the next dash state instead of IDLE
â€ƒâ€ƒâ€ƒend
â€ƒâ€ƒend

â€ƒâ€ƒO_DASH2: begin
â€ƒâ€ƒâ€ƒmorse_out <= 1;
â€ƒâ€ƒâ€ƒif (counter < DASH)
â€ƒâ€ƒâ€ƒâ€ƒcounter <= counter + 1;
â€ƒâ€ƒâ€ƒelse begin
â€ƒâ€ƒâ€ƒâ€ƒcounter <= 0;
â€ƒâ€ƒâ€ƒâ€ƒstate <= O_DASH3;  // transition to the third dash state
â€ƒâ€ƒâ€ƒend
â€ƒâ€ƒend

â€ƒâ€ƒO_DASH3: begin
â€ƒâ€ƒâ€ƒmorse_out <= 1;
â€ƒâ€ƒâ€ƒif (counter < DASH)
â€ƒâ€ƒâ€ƒâ€ƒcounter <= counter + 1;
â€ƒâ€ƒâ€ƒelse begin
â€ƒâ€ƒâ€ƒâ€ƒcounter <= 0;
â€ƒâ€ƒâ€ƒâ€ƒstate <= IDLE;     // finally, return to IDLE
â€ƒâ€ƒâ€ƒâ€ƒmorse_out <= 0;
â€ƒâ€ƒâ€ƒend
â€ƒâ€ƒend
--------------------------------------------------

Doing this ensures that the three dashes for â€œOâ€ are generated in sequence instead of only one dash being produced before resetting the state machine. This change will allow the simulation to generate the correct Morse sequence for â€œOâ€ so that the test bench no longer throws the error.

ğŸ” Related Documents:

- source_documents\verilog_2001_ref_guide.pdf: for (i=0; i<=255; i=i+1)
                @(negedge clk)
                  data_bus = RAM[i];
            end
    default:$display(â€œillegal opcode in module %mâ€);
  endcase
end...

- source_documents\verilog_fsm.pdf: Figure 5 The circuit generated by Program 17 (this is an erroneous circuit!)
Pass
Trigger
C
A
1'b0
0
1
Latch
C
Program 18 An always@( * ) block that will not generate latches
1 wire Trigger , Pass;
2 reg A, C;
3
4 always @( * ) begin
5
A = 1â€™b0;
6
C = 1â€™b1;
7
if (Trigger) begin
8
A = Pass;
9
C = Pass;
10
end
11 end
Figure 6 The circuit generated by Program 18 (this is correct!)
Pass
Trigger
C
A
1'b0
0
1
1
0
1'b1
11...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\RTL error analysis.pdf: // Moore model FSM
module  Moore_Model(
output [1:0]   y_out,
input
X_in, clock, reset
);  
reg [1:0]    state;
parameter S0=2â€™b00, S1=2â€™b01,S2=2â€™b10,S3=2â€™b11;
always @ (posedge clk, negedge reset)
if (reset == 0) state <= S0;
else
case(state)
S0:   if (~X_in) state <= S1; else state <= S0;
S1:   if (X_in)   state <= S2; else state <= S3;
S2:   if (~X_in) state <= S3; else  state <= S2;
S3:   if (~X_in) state <= S0; else   state <= S3;
endcase
assign y_out = state; 
endmodule...

- source_documents\RTL error analysis.pdf: // structural model
module  Moore_Model_One(
output            y_out,A,B,
input
X_in, clock, reset
);  
wire     TA,TB;
assign  TA  = X_in&B;
assign  TB = X_in;
assign   y_out = A&B;
TFF  MA(A,TA,clock,reset);
TFF  MB(B,TB,clock,reset);
end module
// structural model
module  TFF(Q,T,CLK,RST_b);
output            Q;
input
T, CLK,RST_b;
reg
Q; 
always @ (posedge CLK, negedge RST_b)
if (RST_b == 0)  Q<= 1â€™b0;
else if (T)  Q <= ~Q;
end module
Structural description:
clocked sequential circuits...

- source_documents\Quick Start Guide to Verilog.pdf: case statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.
5.2.7
Design a Verilog model to implement the
behavior described by the 4-input truth table
in Fig. 5.4. Use procedural assignment and an
if-else statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output. Hint:
Notice that there are far more input codes pro-...
