The problem turned out not to be in the delays or the clockâ€generation, but rather in how the â€œringâ€ is wired. The designerâ€™s intent was to connect 11 inverters in series where each inverterâ€™s input comes from the previous inverterâ€™s output (with the first inverterâ€™s input coming from the last inverterâ€™s output) so that the overall loop has an odd number of inversions and therefore oscillates. In the code the â€œchainâ€ is implemented with the statement

â€ƒâ€ƒassign lut_ins = {lut_outs[10], lut_outs[9:0]};

but because of the way Verilog concatenation works (the leftmost bit becomes bit10 and the rightmost becomes bit0), the bits wind up being connected oneâ€toâ€one:
â€ƒâ€ƒâ€¢â€ƒlut_ins[10] is driven by lut_outs[10]
â€ƒâ€ƒâ€¢â€ƒlut_ins[9] by lut_outs[9]
â€ƒâ€ƒâ€¢â€ƒâ€¦
â€ƒâ€ƒâ€¢â€ƒlut_ins[0] by lut_outs[0]

This wiring is not â€œrotatingâ€ the outputs through the chain. Instead of each inverter receiving the signal from the previous one, many of the inverters are simply tied to their own outputs or to the wrong signal in the loop. As a result, the inverter chain never â€œseesâ€ a change (and so never toggles), and the test bench eventually gives the error

â€ƒâ€ƒERROR: Ring oscillator output (OUT) never toggled. Likely feedback wiring issue.

To fix the problem you must â€œrotateâ€ the inverter outputs properly, so that the first inverterâ€™s input comes from inverter 10â€™s output and every other inverterâ€™s input comes from the previous one. One correct solution is to change the assignment to

â€ƒâ€ƒassign lut_ins = {lut_outs[9:0], lut_outs[10]};

Now the connections become:
â€ƒâ€ƒâ€¢â€ƒlut_ins[10] = lut_outs[9]â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ (inverter 10 gets the output of inverter 9)
â€ƒâ€ƒâ€¢â€ƒlut_ins[9:1] = lut_outs[8:0]â€ƒâ€ƒâ€ƒâ€ƒâ€ƒ (each inverter i gets the output of inverter iâ€“1)
â€ƒâ€ƒâ€¢â€ƒlut_ins[0] = lut_outs[10]â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ (the first inverter gets the output of inverter 10)
which properly implements the intended ring oscillator and the output will begin toggling.

In summary:
â€ƒâ€¢â€ƒBug: The concatenation on lut_ins was done in the wrong order.
â€ƒâ€¢â€ƒWhy: It wired each inverterâ€™s input to its â€œownâ€ output or the wrong neighbor instead of â€œrotatingâ€ the signals.
â€ƒâ€¢â€ƒFix: Change the assignment to correctly shift the outputs (e.g. assign lut_ins = {lut_outs[9:0], lut_outs[10]};).

This will allow the oscillator to work as intended and the simulation will show a toggling OUT signal.

ğŸ” Related Documents:

- source_documents\verilog_fsm.pdf: Figure 5 The circuit generated by Program 17 (this is an erroneous circuit!)
Pass
Trigger
C
A
1'b0
0
1
Latch
C
Program 18 An always@( * ) block that will not generate latches
1 wire Trigger , Pass;
2 reg A, C;
3
4 always @( * ) begin
5
A = 1â€™b0;
6
C = 1â€™b1;
7
if (Trigger) begin
8
A = Pass;
9
C = Pass;
10
end
11 end
Figure 6 The circuit generated by Program 18 (this is correct!)
Pass
Trigger
C
A
1'b0
0
1
1
0
1'b1
11...

- source_documents\Quick Start Guide to Verilog.pdf: Consider the following forever loop example that will generate a clock signal (CLK), but only when an
enable (EN) is asserted. When EN Â¼ 0, the loop will disable and the simulation will end.
Example:
initial
begin
CLK Â¼ 0;
forever
begin: loop_ex
if (EN Â¼Â¼ 1)
#10 CLK Â¼ ~CLK;
else
disable loop_ex; // The group name to be disabled comes after the keyword
end
end
CONCEPT CHECK
CC5.2
When using an if-else statement to model a combinational logic circuit, is using the else...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\Quick Start Guide to Verilog.pdf: appear in a truth table (i.e., â€œ0000,â€ â€œ0001,â€
â€œ0010,â€ . . .). Your test bench should read in a
new input pattern every 10 ns. Your test bench
should
write
the
input
pattern
and
the
corresponding output of the DUT to an external
ï¬le called â€œoutput.txt.â€
6.4.2
Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 6.2. Your
test bench read in the input patterns from an
external ï¬le called â€œinput.txt.â€ This ï¬le should...

- source_documents\verilog_fsm.pdf: generation. If you donâ€™t assign every element that can be assigned inside an always@( * ) block
every time that always@( * ) block is executed, a latch (similar to a register but much harder to
work with in FPGAs) will be inferred for that element. This is never what you want and is a
terrible place for bugs. As this is subtle, it is somewhat hard to visualize. Consider Program 17.
Program 17 An always@( * ) block that will generate a latch for C
1 wire Trigger , Pass;
2 reg A, C;
3...

- source_documents\RTL error analysis.pdf: clock = 1â€™b0; 
forever
#10   clock = ~clock;
end
Behavioural modeling...
