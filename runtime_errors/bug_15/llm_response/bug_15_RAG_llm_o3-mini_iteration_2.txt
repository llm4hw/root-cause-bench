The problem turned out not to be in the â€œringâ€oscillatorâ€ wiring at all but in how the â€œinverterâ€ is modeled. Notice that the inverter is defined as

â€ƒâ€ƒalways @(*) #1 out = ~in;

When you use a procedural always block like that (instead of a continuous assignment) to model a very fast, delayâ€based inverterâ€”and then string many of them in a feedback loopâ€”the simulator â€œseesâ€ that after the initial evaluation nothing â€œtriggersâ€ an update in the loop. In effect, the loop settles (or â€œfreezesâ€) at a constant value because the delayed update inside the always block does not restart the evaluation as one might expect. (This is similar in spirit to accidentally â€œinferring a latchâ€ when not every branch is assigned.) As a consequence, the supposedly oscillating signal puf_clk (and hence OUT, which is updated only on its rising edge) never toggles; the test bench eventually complains with

â€ƒâ€ƒERROR: Ring oscillator output (OUT) never toggled. Likely feedback wiring issue.

The fix is to model the delay in a way that makes the feedback â€œalive.â€ One common remedy is to replace the alwaysâ€block inverter with a continuous assignment that has the delay. In other words, change the definition of not_with_delay to

â€ƒâ€ƒassign #1 out = ~in;

This continuous assignment with delay ensures that every change on â€œinâ€ will schedule an update for â€œoutâ€ exactly 1 time unit later and that change will then propagate around the ring. (When you string together an odd number of such inverters, you get the expected oscillation.) With that change the ring oscillator will toggle as intended.

In summary:
â€¢ Bug: The inverter was modeled with an always @(*) block that used a delay (#1) so that once the combinational loop settled, no further events triggered and the loop â€œfroze.â€
â€¢ Why: Because the always block (as coded) does not restart when the delayed assignment occurs; the feedback loop then â€œstallsâ€ and puf_clk never sees a rising edge.
â€¢ Fix: Replace the procedural always block with a continuous assignment with delay (assign #1 out = ~in;), which properly propagates every transition through the loop.

ğŸ” Related Documents:

- source_documents\verilog_fsm.pdf: Figure 5 The circuit generated by Program 17 (this is an erroneous circuit!)
Pass
Trigger
C
A
1'b0
0
1
Latch
C
Program 18 An always@( * ) block that will not generate latches
1 wire Trigger , Pass;
2 reg A, C;
3
4 always @( * ) begin
5
A = 1â€™b0;
6
C = 1â€™b1;
7
if (Trigger) begin
8
A = Pass;
9
C = Pass;
10
end
11 end
Figure 6 The circuit generated by Program 18 (this is correct!)
Pass
Trigger
C
A
1'b0
0
1
1
0
1'b1
11...

- source_documents\Quick Start Guide to Verilog.pdf: Consider the following forever loop example that will generate a clock signal (CLK), but only when an
enable (EN) is asserted. When EN Â¼ 0, the loop will disable and the simulation will end.
Example:
initial
begin
CLK Â¼ 0;
forever
begin: loop_ex
if (EN Â¼Â¼ 1)
#10 CLK Â¼ ~CLK;
else
disable loop_ex; // The group name to be disabled comes after the keyword
end
end
CONCEPT CHECK
CC5.2
When using an if-else statement to model a combinational logic circuit, is using the else...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\Quick Start Guide to Verilog.pdf: appear in a truth table (i.e., â€œ0000,â€ â€œ0001,â€
â€œ0010,â€ . . .). Your test bench should read in a
new input pattern every 10 ns. Your test bench
should
write
the
input
pattern
and
the
corresponding output of the DUT to an external
ï¬le called â€œoutput.txt.â€
6.4.2
Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 6.2. Your
test bench read in the input patterns from an
external ï¬le called â€œinput.txt.â€ This ï¬le should...

- source_documents\verilog_fsm.pdf: generation. If you donâ€™t assign every element that can be assigned inside an always@( * ) block
every time that always@( * ) block is executed, a latch (similar to a register but much harder to
work with in FPGAs) will be inferred for that element. This is never what you want and is a
terrible place for bugs. As this is subtle, it is somewhat hard to visualize. Consider Program 17.
Program 17 An always@( * ) block that will generate a latch for C
1 wire Trigger , Pass;
2 reg A, C;
3...

- source_documents\RTL error analysis.pdf: clock = 1â€™b0; 
forever
#10   clock = ~clock;
end
Behavioural modeling...
