The problem turned out not to be with the test bench at all but with how we “wire” our ring oscillator. In our design we want to connect a chain of odd‐number inverters such that the output of inverter 10 drives the input of inverter 0 and every other inverter gets fed by the previous inverter’s output. In other words, we want:

  • inverter[0].in = lut_outs[10]  
  • inverter[i].in = lut_outs[i–1] for i = 1, 2, …, 10

However, the code does the following assignment:

  assign lut_ins = {lut_outs[10], lut_outs[9:0]};

Because of how concatenation works, this actually ties each lut_ins bit directly to the corresponding lut_outs bit. In other words, for inverter[0] you get lut_ins[0] = lut_outs[0] (not lut_outs[10] as desired), for inverter[1] you get lut_ins[1] = lut_outs[1], and so on. (The single bit coming from lut_outs[10] becomes lut_ins[10].) This “self‐connection” means that every inverter is simply inverting its own output rather than being cascaded in a loop. As a consequence, the overall signal never “kicks off” oscillation, and OUT remains static. That is why the test bench eventually reports:

  "ERROR: Ring oscillator output (OUT) never toggled. Likely feedback wiring issue."

To fix the problem you need to shift the LUT outputs so that the chain is correctly formed. One simple solution is to make the wiring explicit. For example, you can do something like this:

-----------------------------------------
module ring_oscillator(
    input wire enable,
    input wire ICE_CLK,
    output reg ICE_LED,
    output reg OUT
);

    wire [10:0] lut_ins;
    wire [10:0] lut_outs;
    
    genvar i;
    generate
        for (i = 0; i < 11; i = i + 1) begin : inverters
            not_with_delay inv (
                .in(lut_ins[i]),
                .out(lut_outs[i])
            );
        end
    endgenerate

    // Correct connection for a ring oscillator:
    // inverter[0].in = lut_outs[10] and for i>=1, inverter[i].in = lut_outs[i-1]
    assign lut_ins[0] = lut_outs[10];
    genvar j;
    generate
        for (j = 1; j < 11; j = j + 1) begin : chain
            assign lut_ins[j] = lut_outs[j-1];
        end
    endgenerate

    wire puf_clk = lut_outs[10];
    reg [15:0] counter = 0;
    
    always @(posedge puf_clk) begin
        if (enable) begin
            counter <= counter + 1;
            ICE_LED <= counter[0];
            OUT <= counter[0];
        end
    end

endmodule

module not_with_delay (
    input wire in,
    output reg out
);
    always @(*) #1 out = ~in;
endmodule
-----------------------------------------

Now inverter[0] gets its input from inverter[10]’s output, inverter[1] from inverter[0]’s output, and so on. With an odd number (11) of inverters, the overall inversion creates a natural oscillation.

In summary:
 • The bug is that the assignment "assign lut_ins = {lut_outs[10], lut_outs[9:0]};" does not create the intended feedback loop but rather ties each inverter’s input to its own output.
 • Because of this “self‐wiring,” the ring oscillator never toggles, so the output remains constant.
 • The fix is to correct the wiring so that inverter[0] receives lut_outs[10] and every other inverter i (for 1 ≤ i < 11) receives lut_outs[i–1].

🔍 Related Documents:

- source_documents\verilog_fsm.pdf: Figure 5 The circuit generated by Program 17 (this is an erroneous circuit!)
Pass
Trigger
C
A
1'b0
0
1
Latch
C
Program 18 An always@( * ) block that will not generate latches
1 wire Trigger , Pass;
2 reg A, C;
3
4 always @( * ) begin
5
A = 1’b0;
6
C = 1’b1;
7
if (Trigger) begin
8
A = Pass;
9
C = Pass;
10
end
11 end
Figure 6 The circuit generated by Program 18 (this is correct!)
Pass
Trigger
C
A
1'b0
0
1
1
0
1'b1
11...

- source_documents\Quick Start Guide to Verilog.pdf: Consider the following forever loop example that will generate a clock signal (CLK), but only when an
enable (EN) is asserted. When EN ¼ 0, the loop will disable and the simulation will end.
Example:
initial
begin
CLK ¼ 0;
forever
begin: loop_ex
if (EN ¼¼ 1)
#10 CLK ¼ ~CLK;
else
disable loop_ex; // The group name to be disabled comes after the keyword
end
end
CONCEPT CHECK
CC5.2
When using an if-else statement to model a combinational logic circuit, is using the else...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\Quick Start Guide to Verilog.pdf: appear in a truth table (i.e., “0000,” “0001,”
“0010,” . . .). Your test bench should read in a
new input pattern every 10 ns. Your test bench
should
write
the
input
pattern
and
the
corresponding output of the DUT to an external
ﬁle called “output.txt.”
6.4.2
Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 6.2. Your
test bench read in the input patterns from an
external ﬁle called “input.txt.” This ﬁle should...

- source_documents\verilog_fsm.pdf: generation. If you don’t assign every element that can be assigned inside an always@( * ) block
every time that always@( * ) block is executed, a latch (similar to a register but much harder to
work with in FPGAs) will be inferred for that element. This is never what you want and is a
terrible place for bugs. As this is subtle, it is somewhat hard to visualize. Consider Program 17.
Program 17 An always@( * ) block that will generate a latch for C
1 wire Trigger , Pass;
2 reg A, C;
3...

- source_documents\RTL error analysis.pdf: clock = 1’b0; 
forever
#10   clock = ~clock;
end
Behavioural modeling...
