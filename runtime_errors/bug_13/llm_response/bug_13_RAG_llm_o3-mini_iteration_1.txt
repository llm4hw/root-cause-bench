The problem is not with the oneâ€bit full adder or half adder modules but with how the four oneâ€bit adders are connected in the 4â€bit adder module. In your full_add_4bit module the carry signals are connected in a â€œscrambledâ€ order. Notice that:

â€¢ In fa1 (the least significant bit), you correctly use i_cin and output its carry to w_carry1.
â€¢ However, in the second adder (fa2) you mistakenly use w_carry3 as its carry input (instead of the carry output from fa1) and output its carry to w_carry2.
â€¢ Then, in fa3 you use w_carry1 (from fa1) again for its carry input instead of using the previous stageâ€™s carry.
â€¢ Finally, in fa4 you use w_carry2 as the carry input and output to w_carry3.

Because the carry chain is broken (the four oneâ€bit adders are not connected in sequence), the adder produces the unexpected result for the test case (3 + 5) where it returned 10010 (binary for 18) instead of the expected 01000 (binary for 8).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
How Itâ€™s Occurring:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
A ripple carry adder must pass the carry output of one full adder as the carry input to the next more significant full adder. In your design, the wires w_carry1, w_carry2, and w_carry3 are connected to different full adder instances in an inconsistent order. Essentially, the output of one stage is not being used as the input of the next stage. This â€œmixinâ€™â€ of carry signals is what causes the arithmetic to be computed incorrectly.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
How to Fix It:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Redesign the wiring so that each full adder receives the correct carry. For example, you can do the following:

1. Rename the intermediate carry wires to reflect the chain order (for instance, w_carry0, w_carry1, and w_carry2).

2. Connect them as follows:
â€ƒâ€ƒâ€¢ fa1: 
â€ƒâ€ƒâ€ƒ- .i_cin(i_cin)
â€ƒâ€ƒâ€ƒ- .o_carry(w_carry0)
â€ƒâ€ƒâ€¢ fa2:
â€ƒâ€ƒâ€ƒ- .i_cin(w_carry0)
â€ƒâ€ƒâ€ƒ- .o_carry(w_carry1)
â€ƒâ€ƒâ€¢ fa3:
â€ƒâ€ƒâ€ƒ- .i_cin(w_carry1)
â€ƒâ€ƒâ€ƒ- .o_carry(w_carry2)
â€ƒâ€ƒâ€¢ fa4:
â€ƒâ€ƒâ€ƒ- .i_cin(w_carry2)
â€ƒâ€ƒâ€ƒ- .o_carry(o_carry)

Thus, the corrected full_add_4bit module might look like this:

--------------------------------------------------
module full_add_4bit(
    i_a,    // input 
    i_b,    // input 
    i_cin,  // input 
    o_sum,  // output 
    o_carry // output 
);

  // Port Declaration
  input  [3:0] i_a, i_b;
  input        i_cin;
  output [3:0] o_sum;
  output       o_carry;
  wire         w_carry0, w_carry1, w_carry2;

  full_half_add_1bit fa1(
    .i_a(i_a[0]),
    .i_b(i_b[0]),
    .i_cin(i_cin),
    .o_sum(o_sum[0]),
    .o_carry(w_carry0)
  );

  full_half_add_1bit fa2(
    .i_a(i_a[1]),
    .i_b(i_b[1]),
    .i_cin(w_carry0),
    .o_sum(o_sum[1]),
    .o_carry(w_carry1)
  );

  full_half_add_1bit fa3(
    .i_a(i_a[2]),
    .i_b(i_b[2]),
    .i_cin(w_carry1),
    .o_sum(o_sum[2]),
    .o_carry(w_carry2)
  );

  full_half_add_1bit fa4(
    .i_a(i_a[3]),
    .i_b(i_b[3]),
    .i_cin(w_carry2),
    .o_sum(o_sum[3]),
    .o_carry(o_carry)
  );
endmodule
--------------------------------------------------

This reordering makes sure that the carry output of each adder correctly â€œripplesâ€ into the next adderâ€™s carry input.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Conclusion
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
The bug was caused by miswiring the carry chain in the 4â€bit full adder instantiation. By correctly connecting the carry signals in a sequential chain (fa1 â†’ fa2 â†’ fa3 â†’ fa4), the arithmetic will produce the expected results (for example, 3 + 5 will yield 8), and the testbench error will be resolved.

ğŸ” Related Documents:

- source_documents\Quick Start Guide to Verilog.pdf: EXAMPLE 4.5 DESIGN OF A HALF ADDER ............................................................. ............................................................. 56
EXAMPLE 4.6 DESIGN OF A FULL ADDER ............................................................. ............................................................. 57
EXAMPLE 4.7 DESIGN OF A FULL ADDER OUT OF HALF ADDERS .............................................. ............................................. 58...

- source_documents\Quick Start Guide to Verilog.pdf: 11.3.4
Add the functionality to the computer model
from 11.3.3 the ability to perform the addition
instruction ADD_AB. Test your addition instruc-
tion by simulating the following program. The
ï¬rst addition instruction will perform xâ€œFEâ€ +
xâ€œ01â€
Â¼
xâ€œFFâ€
and
assert
the
negative
(N) ï¬‚ag. The second addition instruction will
perform xâ€œ01â€ + xâ€œFFâ€ Â¼ xâ€œ00â€ and assert the
carry (C) and zero (Z) ï¬‚ags. The third addition
instruction will perform xâ€œ7Fâ€ + xâ€œ7Fâ€ Â¼ xâ€œFEâ€...

- source_documents\Quick Start Guide to Verilog.pdf: parallel to each other; thus, the delay through the half adder is due to only one level of logic.
Example 4.5
Design of a half adder
4.2.2 Full Adders
A full adder is a circuit that still produces a sum and carry out, but considers three inputs in the
computations (A, B, and Cin). Example 4.6 shows the design of a full adder using the classical design
56
â€¢
Chapter 4: Structural Design and Hierarchy...

- source_documents\Quick Start Guide to Verilog.pdf: Example 4.9
Structural model of a full adder using two half adders
Example 4.10 shows the structural model of a 4-bit ripple carry adder in Verilog. The RCA is created
by instantiating four full adders. Notice that a logic 1â€™b0 can be directly inserted into the port map of the
ï¬rst full adder to model the behavior of C0 Â¼ 0.
60
â€¢
Chapter 4: Structural Design and Hierarchy...

- source_documents\Quick Start Guide to Verilog.pdf: The ability to implement the carry out logic using the expression Cout Â¼ AB + (A  B)Cin allows us to
implement a full adder with two half adders and the addition of a single OR gate. Example 4.7 shows this
approach. In this new conï¬guration, the sum is produced in two levels of logic while the carry out is
produced in three levels of logic.
Example 4.7
Design of a full adder out of half adders
4.2.3 Ripple Carry Adder (RCA)...

- source_documents\Quick Start Guide to Verilog.pdf: always @ (A, B, ALU_Sel)
begin
case (ALU_Sel)
3â€™b000
: begin //-- Addition
//-- Sum and Carry Flag
{NZVC[0], Result} Â¼ A + B;
//-- Negative Flag
NZVC[3] Â¼ Result[7];
//-- Zero Flag
if (Result Â¼Â¼ 0)
NZVC[2] Â¼ 1;
else
NZVC[2] Â¼ 0;
//-- Twoâ€™s Comp Overflow Flag
if ( ((A[7]Â¼Â¼0) && (B[7]Â¼Â¼0) && (Result[7] Â¼Â¼ 1)) ||
((A[7]Â¼Â¼1) && (B[7]Â¼Â¼1) && (Result[7] Â¼Â¼ 0)) )
NZVC[1] Â¼ 1;
else
NZVC[1] Â¼ 0;
end
:
//-- other ALU operations go here...
:
default
: begin
Result Â¼ 8â€™hXX;
NZVC
Â¼ 4â€™hX;
end
endcase
end...
