The problem isnâ€™t in your oneâ€bit (half or full) adder design at allâ€”itâ€™s in how you â€œchainâ€ the carry signals in your 4â€bit full adder. In a normal ripple carry adder the carry output from the lower significant bit must be fed into the carry input of the next bit. In your code, however, the wires are wired in the wrong order. For example:

â€¢ In your first full adder (fa1) you correctly get a carry output on w_carry1.
â€¢ But then for the second full adder (fa2) you mistakenly use w_carry3 as the carry input instead of using w_carry1.
â€¢ fa3 then uses w_carry1 instead of the carry coming from fa2.
â€¢ And fa4 takes w_carry2 as input while its output (w_carry3) is used in fa2.

This â€œmix-upâ€ means that the correct carry isnâ€™t being passed from one full adder to the next. When you add 3 (0011) and 5 (0101) with a carry-in 0, you should get 8 (01000) but because the carry propagation is out of order, you end up with 10010.

The fix is to rewire the 4â€bit adder so that the carry is propagated sequentially:
â€ƒâ€“ Connect fa1â€™s o_carry to fa2â€™s i_cin.
â€ƒâ€“ Connect fa2â€™s o_carry to fa3â€™s i_cin.
â€ƒâ€“ Connect fa3â€™s o_carry to fa4â€™s i_cin.
â€ƒâ€“ Then use fa4â€™s o_carry as the final carry output.

For example, you might declare wires like:
â€ƒwire c0, c1, c2;
and then instantiate your full adders as follows (using c0, c1, c2 correctly):

â€ƒfull_half_add_1bit fa1(
â€ƒâ€ƒ.i_a(i_a[0]),
â€ƒâ€ƒ.i_b(i_b[0]),
â€ƒâ€ƒ.i_cin(i_cin),
â€ƒâ€ƒ.o_sum(o_sum[0]),
â€ƒâ€ƒ.o_carry(c0)
â€ƒ);

â€ƒfull_half_add_1bit fa2(
â€ƒâ€ƒ.i_a(i_a[1]),
â€ƒâ€ƒ.i_b(i_b[1]),
â€ƒâ€ƒ.i_cin(c0),
â€ƒâ€ƒ.o_sum(o_sum[1]),
â€ƒâ€ƒ.o_carry(c1)
â€ƒ);

â€ƒfull_half_add_1bit fa3(
â€ƒâ€ƒ.i_a(i_a[2]),
â€ƒâ€ƒ.i_b(i_b[2]),
â€ƒâ€ƒ.i_cin(c1),
â€ƒâ€ƒ.o_sum(o_sum[2]),
â€ƒâ€ƒ.o_carry(c2)
â€ƒ);

â€ƒfull_half_add_1bit fa4(
â€ƒâ€ƒ.i_a(i_a[3]),
â€ƒâ€ƒ.i_b(i_b[3]),
â€ƒâ€ƒ.i_cin(c2),
â€ƒâ€ƒ.o_sum(o_sum[3]),
â€ƒâ€ƒ.o_carry(o_carry)
â€ƒ);

This change ensures the proper ripple carry behavior and will fix the error reported by your test bench.

ğŸ” Related Documents:

- source_documents\Quick Start Guide to Verilog.pdf: EXAMPLE 4.5 DESIGN OF A HALF ADDER ............................................................. ............................................................. 56
EXAMPLE 4.6 DESIGN OF A FULL ADDER ............................................................. ............................................................. 57
EXAMPLE 4.7 DESIGN OF A FULL ADDER OUT OF HALF ADDERS .............................................. ............................................. 58...

- source_documents\Quick Start Guide to Verilog.pdf: 11.3.4
Add the functionality to the computer model
from 11.3.3 the ability to perform the addition
instruction ADD_AB. Test your addition instruc-
tion by simulating the following program. The
ï¬rst addition instruction will perform xâ€œFEâ€ +
xâ€œ01â€
Â¼
xâ€œFFâ€
and
assert
the
negative
(N) ï¬‚ag. The second addition instruction will
perform xâ€œ01â€ + xâ€œFFâ€ Â¼ xâ€œ00â€ and assert the
carry (C) and zero (Z) ï¬‚ags. The third addition
instruction will perform xâ€œ7Fâ€ + xâ€œ7Fâ€ Â¼ xâ€œFEâ€...

- source_documents\Quick Start Guide to Verilog.pdf: parallel to each other; thus, the delay through the half adder is due to only one level of logic.
Example 4.5
Design of a half adder
4.2.2 Full Adders
A full adder is a circuit that still produces a sum and carry out, but considers three inputs in the
computations (A, B, and Cin). Example 4.6 shows the design of a full adder using the classical design
56
â€¢
Chapter 4: Structural Design and Hierarchy...

- source_documents\Quick Start Guide to Verilog.pdf: Example 4.9
Structural model of a full adder using two half adders
Example 4.10 shows the structural model of a 4-bit ripple carry adder in Verilog. The RCA is created
by instantiating four full adders. Notice that a logic 1â€™b0 can be directly inserted into the port map of the
ï¬rst full adder to model the behavior of C0 Â¼ 0.
60
â€¢
Chapter 4: Structural Design and Hierarchy...

- source_documents\Quick Start Guide to Verilog.pdf: The ability to implement the carry out logic using the expression Cout Â¼ AB + (A  B)Cin allows us to
implement a full adder with two half adders and the addition of a single OR gate. Example 4.7 shows this
approach. In this new conï¬guration, the sum is produced in two levels of logic while the carry out is
produced in three levels of logic.
Example 4.7
Design of a full adder out of half adders
4.2.3 Ripple Carry Adder (RCA)...

- source_documents\Quick Start Guide to Verilog.pdf: always @ (A, B, ALU_Sel)
begin
case (ALU_Sel)
3â€™b000
: begin //-- Addition
//-- Sum and Carry Flag
{NZVC[0], Result} Â¼ A + B;
//-- Negative Flag
NZVC[3] Â¼ Result[7];
//-- Zero Flag
if (Result Â¼Â¼ 0)
NZVC[2] Â¼ 1;
else
NZVC[2] Â¼ 0;
//-- Twoâ€™s Comp Overflow Flag
if ( ((A[7]Â¼Â¼0) && (B[7]Â¼Â¼0) && (Result[7] Â¼Â¼ 1)) ||
((A[7]Â¼Â¼1) && (B[7]Â¼Â¼1) && (Result[7] Â¼Â¼ 0)) )
NZVC[1] Â¼ 1;
else
NZVC[1] Â¼ 0;
end
:
//-- other ALU operations go here...
:
default
: begin
Result Â¼ 8â€™hXX;
NZVC
Â¼ 4â€™hX;
end
endcase
end...
