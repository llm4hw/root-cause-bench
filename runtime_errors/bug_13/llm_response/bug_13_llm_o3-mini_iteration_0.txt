The problem isn’t with the half‐adder or full‐adder logic at all but with how the intermediate “carry” signals are connected between the four adder instances. In your top-level 4‐bit adder, the carry‐out from each individual 1‐bit adder is supposed to be “cascaded” into the carry‐in of the next. In your code the wires that are generated for these “carry” signals (w_carry1, w_carry2, w_carry3) are wrongly assigned to the various full‐adder instances. For example, the second adder instance takes its carry input from w_carry3 (which is actually coming from the fourth adder later in the chain) instead of taking the carry output (w_carry1) from the first adder. Similarly, the third adder uses w_carry1 as its carry input rather than using the carry output from the second adder.

This incorrect “mixing up” means that the cascade is not linear; instead, you create a circular or out‐of-order dependency among the adder stages. The result is that the wrong carry value propagates to later stages and, during simulation of a simple case (3 + 5 with an input carry of 0), the overall sum and final carry do not match the expected value. In your error message, the expected total was 01000 (decimal 8), but the miswired carry chain produced 10010 (decimal 18).

To fix this issue you need to wire each full‐adder so that the carry output of bit 0 feeds the carry input of bit 1, the carry output of bit 1 feeds the carry input of bit 2, and the carry output of bit 2 feeds the carry input of bit 3—with the final carry output taken from the fourth adder. Once the cascade is set up correctly there will be no combinational loop or incorrect dependency and the summing operation will produce the expected result.