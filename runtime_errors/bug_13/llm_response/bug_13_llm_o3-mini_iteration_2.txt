The problem is not with the simulation itself but with how the carry‐signals are wired between the one‐bit adders. In a 4‐bit adder, the output carry from the least significant bit (bit 0) should feed into the next (bit 1), the output of bit 1 should feed bit 2, and so on with the final adder producing the overall carry. In your module, however, the wires that carry the intermediate carry signals are not connected in that sequential order. For example, the instance for bit 1 takes its carry-in from the wire that is produced later by another instance (bit 4’s wire, essentially), and one of the middle adders is using the wrong carry wire entirely. This incorrect chain causes the sum bits and the final carry to be computed from mismatched stages. For the test case (3 + 5 + 0), the expected 5‐bit result “01000” (which is 8 in binary) ends up as “10010” because some of the bits are coming from an adder that never received the proper carry input.

The fix is to reexamine and reassign the carry wires so that each 1‐bit adder’s output carry is correctly connected to the next 1‐bit adder’s carry input. This ensures the correct propagation of carries from the least‐significant bit all the way to the most‐significant bit, thereby producing the right overall result.