The error isnâ€™t in the halfâ€‘adder or the addition algorithm itselfâ€”itâ€™s due to misâ€wiring of the â€œchainâ€ between the full adders. In a proper 4â€‘bit rippleâ€‘carry adder, the carry output of each stage must feed into the carry input of the next stage.

Looking at the code:

â€¢ fa1 (the least significant bit) is set up correctly:
â€ƒâ€ƒâ€¢ i_cin is passed as the carryâ€in,
â€ƒâ€ƒâ€¢ Its carry-out goes to w_carry1.

â€¢ However, fa2 is instantiated with:
â€ƒâ€ƒâ€¢ i_cin(w_carry3)
â€ƒâ€ƒâ€¢ o_carry(w_carry2)
â€ƒâ€ƒThis is incorrect because it should take the carry-out from fa1â€”not from w_carry3!

â€¢ Then, fa3 uses:
â€ƒâ€ƒâ€¢ i_cin(w_carry1)
â€ƒâ€ƒâ€¢ o_carry(o_carry)
â€ƒâ€ƒAgain, this should instead take the carry-out coming from fa2.

â€¢ Finally, fa4 is instantiated with:
â€ƒâ€ƒâ€¢ i_cin(w_carry2)
â€ƒâ€ƒâ€¢ o_carry(w_carry3)
â€ƒâ€ƒThis one almost â€œclosesâ€ the chain, but then w_carry3 is (incorrectly) routed back to fa2 in the chain.

Because of these mix-ups, when you add numbers like 3 (0011) and 5 (0101) the fanâ€‘out and the carry propagation are not whatâ€™s expected. Thus the testbench, which checks for {cout, sum} = 01000 (for 8), sees an incorrect value (10010) due to the wrong ordering of the carry signals.

To fix the problem, connect the full adders in proper rippleâ€‘carry order. For instance, you should have:
â€ƒâ€¢ fa1: 
â€ƒâ€ƒâ€ƒ.i_cin(i_cin)
â€ƒâ€ƒâ€ƒ.o_carry(w_carry1)
â€ƒâ€¢ fa2: 
â€ƒâ€ƒâ€ƒ.i_cin(w_carry1)â€ƒâ€ƒ// instead of w_carry3
â€ƒâ€ƒâ€ƒ.o_carry(w_carry2)
â€ƒâ€¢ fa3: 
â€ƒâ€ƒâ€ƒ.i_cin(w_carry2)â€ƒâ€ƒ// instead of w_carry1
â€ƒâ€ƒâ€ƒ.o_carry(w_carry3)
â€ƒâ€¢ fa4: 
â€ƒâ€ƒâ€ƒ.i_cin(w_carry3)â€ƒâ€ƒ// instead of w_carry2
â€ƒâ€ƒâ€ƒ.o_carry(o_carry)

With these connections, the carries are chained correctly and the final sum (and carry-out) will match the expected addition.

ğŸ” Related Documents:

- source_documents\Quick Start Guide to Verilog.pdf: EXAMPLE 4.5 DESIGN OF A HALF ADDER ............................................................. ............................................................. 56
EXAMPLE 4.6 DESIGN OF A FULL ADDER ............................................................. ............................................................. 57
EXAMPLE 4.7 DESIGN OF A FULL ADDER OUT OF HALF ADDERS .............................................. ............................................. 58...

- source_documents\Quick Start Guide to Verilog.pdf: 11.3.4
Add the functionality to the computer model
from 11.3.3 the ability to perform the addition
instruction ADD_AB. Test your addition instruc-
tion by simulating the following program. The
ï¬rst addition instruction will perform xâ€œFEâ€ +
xâ€œ01â€
Â¼
xâ€œFFâ€
and
assert
the
negative
(N) ï¬‚ag. The second addition instruction will
perform xâ€œ01â€ + xâ€œFFâ€ Â¼ xâ€œ00â€ and assert the
carry (C) and zero (Z) ï¬‚ags. The third addition
instruction will perform xâ€œ7Fâ€ + xâ€œ7Fâ€ Â¼ xâ€œFEâ€...

- source_documents\Quick Start Guide to Verilog.pdf: parallel to each other; thus, the delay through the half adder is due to only one level of logic.
Example 4.5
Design of a half adder
4.2.2 Full Adders
A full adder is a circuit that still produces a sum and carry out, but considers three inputs in the
computations (A, B, and Cin). Example 4.6 shows the design of a full adder using the classical design
56
â€¢
Chapter 4: Structural Design and Hierarchy...

- source_documents\Quick Start Guide to Verilog.pdf: Example 4.9
Structural model of a full adder using two half adders
Example 4.10 shows the structural model of a 4-bit ripple carry adder in Verilog. The RCA is created
by instantiating four full adders. Notice that a logic 1â€™b0 can be directly inserted into the port map of the
ï¬rst full adder to model the behavior of C0 Â¼ 0.
60
â€¢
Chapter 4: Structural Design and Hierarchy...

- source_documents\Quick Start Guide to Verilog.pdf: The ability to implement the carry out logic using the expression Cout Â¼ AB + (A  B)Cin allows us to
implement a full adder with two half adders and the addition of a single OR gate. Example 4.7 shows this
approach. In this new conï¬guration, the sum is produced in two levels of logic while the carry out is
produced in three levels of logic.
Example 4.7
Design of a full adder out of half adders
4.2.3 Ripple Carry Adder (RCA)...

- source_documents\Quick Start Guide to Verilog.pdf: always @ (A, B, ALU_Sel)
begin
case (ALU_Sel)
3â€™b000
: begin //-- Addition
//-- Sum and Carry Flag
{NZVC[0], Result} Â¼ A + B;
//-- Negative Flag
NZVC[3] Â¼ Result[7];
//-- Zero Flag
if (Result Â¼Â¼ 0)
NZVC[2] Â¼ 1;
else
NZVC[2] Â¼ 0;
//-- Twoâ€™s Comp Overflow Flag
if ( ((A[7]Â¼Â¼0) && (B[7]Â¼Â¼0) && (Result[7] Â¼Â¼ 1)) ||
((A[7]Â¼Â¼1) && (B[7]Â¼Â¼1) && (Result[7] Â¼Â¼ 0)) )
NZVC[1] Â¼ 1;
else
NZVC[1] Â¼ 0;
end
:
//-- other ALU operations go here...
:
default
: begin
Result Â¼ 8â€™hXX;
NZVC
Â¼ 4â€™hX;
end
endcase
end...
