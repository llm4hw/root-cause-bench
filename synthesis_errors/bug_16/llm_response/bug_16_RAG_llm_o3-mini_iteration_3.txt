The error occurs because out1 is assigned unconditionally in an always block with an asynchronous reset in its sensitivity list, but the reset branch does not assign a value to out1. In other words, the asynchronous reset condition is applied only to the signal "data" (which uses a nonblocking assignment), while out1 (a registered output) is assigned with blocking assignment and is not explicitly reset. This prevents the synthesis tool from correctly extracting an asynchronous set/reset for the out1 flip‚Äêflop.

In sequential logic with an asynchronous reset, every register that appears in the always block must have a defined value when the reset is asserted. In this case, out1 is assigned only after the if/else but only ‚Äúdata‚Äù is reset. Also, mixing blocking and nonblocking assignments in a sequential always block can create mismatches between simulation and synthesis.

To fix the issue, you should:
1. Assign both data and out1 using nonblocking assignments.
2. Include an assignment for out1 in the reset condition, or derive out1 solely from data in a way that the asynchronous reset is properly extracted.

For example, you can change the always block to:

--------------------------------------------------
always @(posedge clk or posedge rst)
begin
    if (rst) begin
        data <= 1'b0;
        out1 <= 1'b0;
    end
    else begin
        data <= ~data;
        out1 <= data;
    end
end
--------------------------------------------------

This ensures that both registers (data and out1) are properly reset when rst is high and uses nonblocking assignments consistently. This will allow the synthesis tool to extract the asynchronous reset correctly for all the registers in your design.

üîç Related Documents:

- source_documents\verilog_2001_ref_guide.pdf: for (i=0; i<=255; i=i+1)
                @(negedge clk)
                  data_bus = RAM[i];
            end
    default:$display(‚Äúillegal opcode in module %m‚Äù);
  endcase
end...

- source_documents\Quick Start Guide to Verilog.pdf: widely used in data path modeling and computer system design. Example 7.6 shows an RTL model of an
8-bit, synchronous register. This circuit has an active LOW, asynchronous reset that will cause the 8-bit
output Reg_Out to go to 0 when it is asserted. When the reset is not asserted, the output will be updated
with the 8-bit input Reg_In if the system is enabled (EN ¬º 1) and there is a rising edge on the clock. If the...

- source_documents\Quick Start Guide to Verilog.pdf: Design a Verilog model for the 16  8, asyn-
chronous, read-only memory system shown in
Fig. 10.2. The system should contain the infor-
mation provided in the memory map. Create a
test bench to simulate your model by reading
from each of the 16 unique addresses and
observing data_out to verify it contains the
information in the memory map.
Fig. 10.2
16 x 8 Asynchronous ROM Block Diagram
10.2.2
Design a Verilog model for the 16  8, synchro-
nous, read-only memory system shown in...

- source_documents\Quick Start Guide to Verilog.pdf: signal_assignment_1
signal_assignment_2
:
end
Let‚Äôs look at a simple model of how an initial block is used to model the reset line in a test bench. In
the following example, the signal ‚ÄúReset_TB‚Äù is being driven into a DUT. At the beginning of the
simulation, the initial value of Reset_TB is set to a logic zero. The second assignment will take place
after a delay of 15 time units. The second assignment statement sets Reset_TB to a logic one. The...

- source_documents\verilog_fsm.pdf: Figure 5 The circuit generated by Program 17 (this is an erroneous circuit!)
Pass
Trigger
C
A
1'b0
0
1
Latch
C
Program 18 An always@( * ) block that will not generate latches
1 wire Trigger , Pass;
2 reg A, C;
3
4 always @( * ) begin
5
A = 1‚Äôb0;
6
C = 1‚Äôb1;
7
if (Trigger) begin
8
A = Pass;
9
C = Pass;
10
end
11 end
Figure 6 The circuit generated by Program 18 (this is correct!)
Pass
Trigger
C
A
1'b0
0
1
1
0
1'b1
11...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...
