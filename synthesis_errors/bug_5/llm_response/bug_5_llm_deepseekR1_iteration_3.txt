### Issue Explanation
The error occurs because you are attempting to directly index (bit-select) the result of a type conversion function (`std_logic_vector(to_unsigned(...))`). In VHDL, **the result of a function call cannot be indexed immediately** because it is treated as a transient value without a defined object structure. The synthesis tool cannot resolve indexing on a transient value generated by nested function calls.

### Breakdown of the Problematic Line
```vhdl
out1 <= std_logic_vector(to_unsigned(counter, 8))(7);
```
Here:
1. `to_unsigned(counter, 8)` converts `counter` to an 8-bit `unsigned` type.
2. `std_logic_vector(...)` converts the `unsigned` result to `std_logic_vector`.
3. `(...)(7)` attempts to access bit 7 (MSB) of the transient `std_logic_vector` result.

The tool flags this as invalid because **indexing requires a stable object (e.g., signal/variable), not a transient value from a function call chain**.

### Solution Approach
To fix this, you need to **separate the conversion and indexing operations**:
1. **Option 1**: Assign the conversion result to an intermediate signal, then index that signal:
   ```vhdl
   signal temp : std_logic_vector(7 downto 0);
   ...
   temp <= std_logic_vector(to_unsigned(counter, 8));
   out1 <= temp(7);
   ```
2. **Option 2**: Index the `unsigned` result directly (avoids redundant conversion):
   ```vhdl
   out1 <= to_unsigned(counter, 8)(7); -- No need for std_logic_vector
   ```
   (This works because `unsigned` supports indexing, and the bit type `std_logic` matches `out1`).

### Why This Fix Works
- **Intermediate Signal**: Creates a stable object (`temp`) that can be indexed.
- **Direct Indexing on `unsigned`**: Bypasses the problematic nested conversion since `to_unsigned` already returns an indexable array type (`unsigned`).

### Key Takeaway
Always ensure indexing is applied to **named objects (signals/variables)**, not transient values from function calls. This aligns with VHDL's strict typing and synthesis requirements.