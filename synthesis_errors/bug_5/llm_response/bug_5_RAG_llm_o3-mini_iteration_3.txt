The error arises because the code is trying to index directly into the result of a type conversion expression. In the line

â€ƒâ€ƒout1 <= std_logic_vector(to_unsigned(counter, 8))(7);

the function to_unsigned(counter, 8) returns an unsigned value that is then converted to a std_logic_vector. However, the synthesis tool (and the test bench in simulation) doesn't allow directly indexing into a temporaryâ€”i.e. a result of a conversionâ€”rather than a signal or variable that has been previously assigned a value.

To fix this error, you need to break the operation into two steps. First, perform the conversion and assign the result to an intermediate signal (or variable) and then index that signal. For example:

â€ƒâ€ƒarchitecture Behavioral of top5 is
â€ƒâ€ƒâ€ƒsignal temp_vector : std_logic_vector(7 downto 0);
â€ƒâ€ƒâ€ƒsignal counter : integer range 0 to 255 := 0;
â€ƒâ€ƒbegin
â€ƒâ€ƒâ€ƒprocess (clk, rst)
â€ƒâ€ƒâ€ƒbegin
â€ƒâ€ƒâ€ƒâ€ƒif rst = '1' then
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒcounter <= 0;
â€ƒâ€ƒâ€ƒâ€ƒelsif rising_edge(clk) then
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒif counter < 255 then
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒcounter <= counter + 1;
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒend if;
â€ƒâ€ƒâ€ƒâ€ƒend if;
â€ƒâ€ƒâ€ƒend process;
â€ƒâ€ƒâ€ƒ
â€ƒâ€ƒâ€ƒtemp_vector <= std_logic_vector(to_unsigned(counter, 8));
â€ƒâ€ƒâ€ƒout1 <= temp_vector(7);
â€ƒâ€ƒend Behavioral;

This way, the conversion is done separately, and then the highest-order bit is selected from the intermediate signal. This approach avoids the illegal indexing of a temporary result and resolves the synthesis error.

ðŸ” Related Documents:

- source_documents\verilog_2001_ref_guide.pdf: for (i=0; i<=255; i=i+1)
                @(negedge clk)
                  data_bus = RAM[i];
            end
    default:$display(â€œillegal opcode in module %mâ€);
  endcase
end...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\Quick Start Guide to Verilog.pdf: EXAMPLE 8.12 2-BIT UP/DOWN COUNTER IN VERILOGâ€”DESIGN DESCRIPTION AND PORT DEFINITION ................... ................... 123
EXAMPLE 8.13 2-BIT UP/DOWN COUNTER IN VERILOGâ€”FULL MODEL (THREE-BLOCK APPROACH) ..................... ..................... 124
EXAMPLE 8.14 2-BIT UP/DOWN COUNTER IN VERILOGâ€”SIMULATION WAVEFORM ................................. ................................. 124...

- source_documents\Quick Start Guide to Verilog.pdf: Example 8.11 shows the resulting simulation waveform for this design.
Example 8.11
Vending machine controller in Verilogâ€”simulation waveform
8.2.3 2-Bit, Binary Up/Down Counter in Verilog
Letâ€™s now look at how a simple counter can be implemented using the three-block behavioral
modeling approach in Verilog. Example 8.12 shows the design description and port deï¬nition for the
2-bit, binary up/down counter FSM from Chap. 7.
Example 8.12...

- source_documents\Quick Start Guide to Verilog.pdf: ment from 000002 to 111112 and then start
over. Use delay in your loop to update the
counter value every 10 ns. Consider using the
loop variable of the for loop to generate an
integer version of your count value, and then
assign it to the output variable of type reg[4:0].
Fig. 5.7
5-Bit Binary Counter Block Diagram
Section 5.3: System Tasks
5.3.1
Are system tasks synthesizable? Why or why
not?
5.3.2
What is the difference between the tasks $dis-
play() and $write()?
5.3.3...

- source_documents\Quick Start Guide to Verilog.pdf: ule deï¬nition. The counter should increment
from 0 to 31 and then start over. Use delay in
your loop to update the counter value every
10 ns. Consider using the loop variable of the
for loop to generate your counter value.
Fig. 5.6
Integer Counter Block Diagram
5.2.11
Design a Verilog model for a counter using a
for loop with an output type of reg[4:0].
Figure 5.7 shows the block diagram for the
module deï¬nition. The counter should incre-
ment from 000002 to 111112 and then start...
