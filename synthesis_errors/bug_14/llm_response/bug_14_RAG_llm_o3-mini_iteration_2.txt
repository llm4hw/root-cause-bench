The bug is that the signal "data" is never declared in the module. When the statement

â€ƒâ€ƒout1 <= data;

is executed, the synthesis and simulation tools cannot find a definition for "data." This is why you see the error message that "data is not declared" at the specified line.

Why it's occurring:
â€¢ In Verilog, you must declare all signals (wires, regs, etc.) that you use.
â€¢ The error is raised because the test bench (and the underlying synthesis tool) cannot find any declaration such as "wire data;" or "reg data;" within your module or its inputs/outputs.

How to fix it:
â€¢ Declare the variable "data" within your module by adding a declaration line. For example, if "data" is supposed to be a register, you could add:
â€ƒâ€ƒreg data;
at the beginning of the module, along with any specification of its width if needed. 
â€¢ Alternatively, if "data" was intended to be connected to something or computed within the module (or provided as an input), you must connect it properly by declaring it as an input or internal signal.

For instance, if "data" is supposed to be a 1-bit signal coming from somewhere, you might modify your module as follows:

â€ƒâ€ƒmodule top14(
â€ƒâ€ƒâ€ƒâ€ƒinput wire clk,
â€ƒâ€ƒâ€ƒâ€ƒinput wire data,â€ƒâ€ƒâ€ƒ// Added input declaration for data
â€ƒâ€ƒâ€ƒâ€ƒoutput reg out1
â€ƒâ€ƒ);

â€ƒâ€ƒalways @(posedge clk)
â€ƒâ€ƒbegin
â€ƒâ€ƒâ€ƒâ€ƒout1 <= data;
â€ƒâ€ƒend

Or, if "data" is supposed to be generated internally, declare it as a reg and assign it a value within your module.

By properly declaring "data," you fix the error.

ðŸ” Related Documents:

- source_documents\verilog_2001_ref_guide.pdf: for (i=0; i<=255; i=i+1)
                @(negedge clk)
                  data_bus = RAM[i];
            end
    default:$display(â€œillegal opcode in module %mâ€);
  endcase
end...

- source_documents\verilog_fsm.pdf: case with simulation tools (like ModelSim), however. ModelSim will not correct your sensitivity
list bugs, and your simulations will be plagued with odd errors. Furthermore, the synthesis tools
catching your errors is not guarenteed. An easy way to avoid these potential problems is to use
always@( * ) as opposed to always@(Input1 or Input 2 or ...).
4. Lastly, a very subtle point which perhaps has the potential to cause the most frustration is latch...

- source_documents\Quick Start Guide to Verilog.pdf: data_out Â¼ rom_data_out;
else if ( (address >Â¼ 128) && (address <Â¼ 223) )
data_out Â¼ rw_data_out;
else if (address Â¼Â¼ 8â€™hF0) data_out Â¼ port_in_00;
else if (address Â¼Â¼ 8â€™hF1) data_out Â¼ port_in_01;
else if (address Â¼Â¼ 8â€™hF2) data_out Â¼ port_in_02;
else if (address Â¼Â¼ 8â€™hF3) data_out Â¼ port_in_03;
else if (address Â¼Â¼ 8â€™hF4) data_out Â¼ port_in_04;
else if (address Â¼Â¼ 8â€™hF5) data_out Â¼ port_in_05;
else if (address Â¼Â¼ 8â€™hF6) data_out Â¼ port_in_06;
else if (address Â¼Â¼ 8â€™hF7) data_out Â¼ port_in_07;...

- source_documents\Quick Start Guide to Verilog.pdf: assignments will be attempted for addresses outside of the deï¬ned range of the ROM array. This enable
line can now be used in the behavioral model for the ROM as follows:
always @ (posedge clock)
begin
if (EN)
data_out Â¼ ROM[address];
end
11.3.3.2 Data Memory Implementation in Verilog
The data memory is created using a similar strategy as the program memory. An array signal is
declared with an address range corresponding to the memory map for the computer system (i.e., 128 to...

- source_documents\Quick Start Guide to Verilog.pdf: ROM to data_out when a valid address is entered. Consider the following Verilog to create an internal
enable (EN) that will only be asserted when the address falls within the valid program memory range of
0 to 127.
always @ (address)
begin
if ( (address >Â¼ 0) && (address <Â¼ 127) )
EN Â¼ 1â€™b1;
else
EN Â¼ 1â€™b0;
end
If this enable signal is not created, the simulation and synthesis will fail because data_out...

- source_documents\Quick Start Guide to Verilog.pdf: else if (address Â¼Â¼ 8â€™hF7) data_out Â¼ port_in_07;
else if (address Â¼Â¼ 8â€™hF8) data_out Â¼ port_in_08;
else if (address Â¼Â¼ 8â€™hF9) data_out Â¼ port_in_09;
else if (address Â¼Â¼ 8â€™hFA) data_out Â¼ port_in_10;
else if (address Â¼Â¼ 8â€™hFB) data_out Â¼ port_in_11;
else if (address Â¼Â¼ 8â€™hFC) data_out Â¼ port_in_12;
else if (address Â¼Â¼ 8â€™hFD) data_out Â¼ port_in_13;
else if (address Â¼Â¼ 8â€™hFE) data_out Â¼ port_in_14;
else if (address Â¼Â¼ 8â€™hFF) data_out Â¼ port_in_15;
end
11.3.4 CPU Implementation...
