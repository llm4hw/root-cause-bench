The problem is that the way the reset condition is written in the if‐statement doesn’t match the reset edge (negedge) specified in the sensitivity list. In the code, the condition is written as if (!reset == 0), which—due to operator precedence—evaluates as if ((!reset) == 0). In a one‐bit signal, this means that when reset is asserted low (active), the expression (!reset) becomes high (1) and then comparing 1 to 0 yields false. Conversely, when reset is deasserted high, the expression evaluates to false (0) and then 0 == 0 yields true. This is the opposite of what you usually intend for an asynchronous, active‐low reset.

Moreover, many synthesis tools (or in this case a test bench check) expect that when you have an asynchronous reset (triggered on a specific edge—in this case negedge reset), the condition inside the always block directly tests the reset level (for example, by simply checking if the reset is low or high) rather than performing a secondary comparison. This mismatch between the reset edge in the event control and the condition causes the tool to flag an error.

To resolve the issue, you would need to align the if condition with the intended active low behavior that the sensitivity list indicates. In essence, the reset checking should directly match the edge (negedge) used in the sensitivity list rather than using a logical operation that reverses the intended polarity.
